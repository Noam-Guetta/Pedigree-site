import React, { useMemo, useState } from "react";
import { motion } from "framer-motion";

// -----------------------------
// Types
// -----------------------------

type Sex = "M" | "F";

type Node = {
  id: string;
  sex: Sex;
  spouseId?: string;
  fatherId?: string;
  motherId?: string;
};

type Pedigree = {
  id: string;
  name: string;
  nodes: Node[];
};

type Inheritance =
  | "Autosomal Dominant"
  | "Autosomal Recessive"
  | "X-Linked Dominant"
  | "X-Linked Recessive"
  | "Y-Linked"
  | "Mitochondrial";

type Mode = "common" | "rare";

type Geno = { code: string };

// -----------------------------
// Utilities
// -----------------------------

const rand = (n: number) => Math.floor(Math.random() * n);
const choice = <T,>(arr: T[]) => arr[rand(arr.length)];
function sample<T>(pairs: Array<[T, number]>) { const r = Math.random(); let a = 0; for (const [t,p] of pairs){ a+=p; if(r<=a) return t;} return pairs[pairs.length-1][0]; }

// -----------------------------
// Pedigree templates (added several samples)
// -----------------------------

const PEDS: Pedigree[] = [
  // A) Three-Generation – Branching
  {
    id: "p1",
    name: "Three-Generation – Branching",
    nodes: [
      { id: "I1", sex: "M", spouseId: "I2" },
      { id: "I2", sex: "F", spouseId: "I1" },

      { id: "II1", sex: "F", fatherId: "I1", motherId: "I2", spouseId: "II1s" },
      { id: "II1s", sex: "M", spouseId: "II1" },

      { id: "II2", sex: "F", fatherId: "I1", motherId: "I2", spouseId: "II2s" },
      { id: "II2s", sex: "M", spouseId: "II2" },

      { id: "II3", sex: "M", fatherId: "I1", motherId: "I2", spouseId: "II3s" },
      { id: "II3s", sex: "F", spouseId: "II3" },

      { id: "III1", sex: "M", fatherId: "II1s", motherId: "II1" },
      { id: "III2", sex: "F", fatherId: "II1s", motherId: "II1" },
      { id: "III3", sex: "M", fatherId: "II1s", motherId: "II1" },

      { id: "III4", sex: "F", fatherId: "II2s", motherId: "II2" },
      { id: "III5", sex: "M", fatherId: "II2s", motherId: "II2" },
      { id: "III6", sex: "M", fatherId: "II2s", motherId: "II2" },

      { id: "III7", sex: "M", fatherId: "II3", motherId: "II3s" },
      { id: "III8", sex: "F", fatherId: "II3", motherId: "II3s" },
      { id: "III9", sex: "M", fatherId: "II3", motherId: "II3s" },
    ],
  },
  // B) Two-Branches with Cousins
  {
    id: "p2",
    name: "Two-Branches with Cousins",
    nodes: [
      { id: "I1", sex: "F", spouseId: "I2" },
      { id: "I2", sex: "M", spouseId: "I1" },

      { id: "II1", sex: "M", fatherId: "I2", motherId: "I1", spouseId: "II1s" },
      { id: "II1s", sex: "F", spouseId: "II1" },
      { id: "II2", sex: "F", fatherId: "I2", motherId: "I1", spouseId: "II2s" },
      { id: "II2s", sex: "M", spouseId: "II2" },

      { id: "III1", sex: "M", fatherId: "II1", motherId: "II1s" },
      { id: "III2", sex: "M", fatherId: "II1", motherId: "II1s" },
      { id: "III3", sex: "F", fatherId: "II2s", motherId: "II2" },
      { id: "III4", sex: "M", fatherId: "II2s", motherId: "II2" },

      { id: "III5", sex: "F", fatherId: "II2s", motherId: "II2", spouseId: "III5s" },
      { id: "III5s", sex: "M", spouseId: "III5" },
      { id: "IV1", sex: "M", fatherId: "III5s", motherId: "III5" },
      { id: "IV2", sex: "F", fatherId: "III5s", motherId: "III5" },
    ],
  },
  // C) Big Sibship + spouses
  {
    id: "p3",
    name: "Big Sibship",
    nodes: [
      { id: "I1", sex: "M", spouseId: "I2" },
      { id: "I2", sex: "F", spouseId: "I1" },

      { id: "II1", sex: "F", fatherId: "I1", motherId: "I2", spouseId: "II1s" },
      { id: "II1s", sex: "M", spouseId: "II1" },
      { id: "II2", sex: "M", fatherId: "I1", motherId: "I2", spouseId: "II2s" },
      { id: "II2s", sex: "F", spouseId: "II2" },
      { id: "II3", sex: "M", fatherId: "I1", motherId: "I2" },
      { id: "II4", sex: "F", fatherId: "I1", motherId: "I2" },

      { id: "III1", sex: "F", fatherId: "II1s", motherId: "II1" },
      { id: "III2", sex: "M", fatherId: "II1s", motherId: "II1" },
      { id: "III3", sex: "M", fatherId: "II2", motherId: "II2s" },
      { id: "III4", sex: "F", fatherId: "II2", motherId: "II2s" },
    ],
  },
  // D) Wide sibship with two married-in partners (sample)
  {
    id: "p4",
    name: "Wide sibship + married-in",
    nodes: [
      { id: "I1", sex: "M", spouseId: "I2" },
      { id: "I2", sex: "F", spouseId: "I1" },

      { id: "II1", sex: "M", fatherId: "I1", motherId: "I2", spouseId: "II1s" },
      { id: "II1s", sex: "F", spouseId: "II1" },
      { id: "II2", sex: "F", fatherId: "I1", motherId: "I2", spouseId: "II2s" },
      { id: "II2s", sex: "M", spouseId: "II2" },
      { id: "II3", sex: "M", fatherId: "I1", motherId: "I2" },
      { id: "II4", sex: "F", fatherId: "I1", motherId: "I2" },

      { id: "III1", sex: "M", fatherId: "II1", motherId: "II1s" },
      { id: "III2", sex: "F", fatherId: "II1", motherId: "II1s" },
      { id: "III3", sex: "F", fatherId: "II2s", motherId: "II2" },
      { id: "III4", sex: "M", fatherId: "II2s", motherId: "II2" },
      { id: "III5", sex: "M", fatherId: "II2s", motherId: "II2" },
    ],
  },
  // E) Left-heavy grandchildren tree (sample)
  {
    id: "p5",
    name: "Left-heavy grandchildren",
    nodes: [
      { id: "I1", sex: "F", spouseId: "I2" },
      { id: "I2", sex: "M", spouseId: "I1" },

      { id: "II1", sex: "M", fatherId: "I2", motherId: "I1", spouseId: "II1s" },
      { id: "II1s", sex: "F", spouseId: "II1" },
      { id: "II2", sex: "F", fatherId: "I2", motherId: "I1", spouseId: "II2s" },
      { id: "II2s", sex: "M", spouseId: "II2" },

      { id: "III1", sex: "M", fatherId: "II1", motherId: "II1s" },
      { id: "III2", sex: "F", fatherId: "II1", motherId: "II1s" },
      { id: "III3", sex: "M", fatherId: "II1", motherId: "II1s" },

      { id: "III4", sex: "F", fatherId: "II2s", motherId: "II2", spouseId: "III4s" },
      { id: "III4s", sex: "M", spouseId: "III4" },
      { id: "IV1", sex: "M", fatherId: "III4s", motherId: "III4" },
      { id: "IV2", sex: "F", fatherId: "III4s", motherId: "III4" },
    ],
  },
  // F) Broad bottom sibship (sample)
  {
    id: "p6",
    name: "Broad bottom sibship",
    nodes: [
      { id: "I1", sex: "F", spouseId: "I2" },
      { id: "I2", sex: "M", spouseId: "I1" },

      { id: "II1", sex: "F", fatherId: "I2", motherId: "I1", spouseId: "II1s" },
      { id: "II1s", sex: "M", spouseId: "II1" },
      { id: "II2", sex: "M", fatherId: "I2", motherId: "I1", spouseId: "II2s" },
      { id: "II2s", sex: "F", spouseId: "II2" },

      { id: "III1", sex: "M", fatherId: "II2", motherId: "II2s" },
      { id: "III2", sex: "F", fatherId: "II2", motherId: "II2s" },
      { id: "III3", sex: "M", fatherId: "II2", motherId: "II2s" },
      { id: "III4", sex: "F", fatherId: "II2", motherId: "II2s" },
    ],
  },
];

// -----------------------------
// Genetics core
// -----------------------------

function hardyWeinbergAutosoma(q: number) { const p = 1 - q; return { AA: p*p, Aa: 2*p*q, aa: q*q }; }

function foundersGenotype(sex: Sex, model: Inheritance, mode: Mode, q: number): Geno {
  if (model === "Mitochondrial") return { code: Math.random() < q ? "m" : "M" };
  if (model === "Y-Linked") return sex === "M" ? { code: Math.random() < q ? "Y*" : "Y" } : { code: "-" };
  if (model.includes("X-Linked")) {
    if (sex === "M") return { code: Math.random() < q ? "x" : "X" };
    const hw = hardyWeinbergAutosoma(q); return { code: sample([["XX",hw.AA],["Xx",hw.Aa],["xx",hw.aa]]) };
  }
  const hw = hardyWeinbergAutosoma(q); return { code: sample([["AA",hw.AA],["Aa",hw.Aa],["aa",hw.aa]]) };
}

function childFromParents(childSex: Sex, model: Inheritance, dad: Geno, mom: Geno): Geno {
  const pick = (pair: string) => pair[rand(pair.length)];
  switch (model) {
    case "Autosomal Dominant":
    case "Autosomal Recessive": {
      const da = pick(/[Aa]{2}/.test(dad.code) ? dad.code : "AA");
      const ma = pick(/[Aa]{2}/.test(mom.code) ? mom.code : "AA");
      return { code: (da+ma).split("").sort().join("") };
    }
    case "X-Linked Recessive":
    case "X-Linked Dominant": {
      const momAlleles = (mom.code.match(/[Xx]/g) || ["X","X"]).join("");
      if (childSex === "M") { const xm = momAlleles[rand(momAlleles.length)]; return { code: xm === "x" ? "x" : "X" }; }
      const xd = dad.code === "x" ? "x" : "X"; const xm = momAlleles[rand(momAlleles.length)]; return { code: (xd+xm).split("").sort().join("") };
    }
    case "Y-Linked": { return childSex === "M" ? { code: dad.code === "Y*" ? "Y*" : "Y" } : { code: "-" }; }
    case "Mitochondrial": { return { code: mom.code === "m" ? "m" : "M" }; }
  }
}

function isAffected(model: Inheritance, sex: Sex, g: Geno): boolean {
  switch (model) {
    case "Autosomal Dominant": return g.code === "Aa" || g.code === "aa";
    case "Autosomal Recessive": return g.code === "aa";
    case "X-Linked Dominant": return sex === "M" ? g.code === "x" : g.code === "Xx" || g.code === "xx";
    case "X-Linked Recessive": return sex === "M" ? g.code === "x" : g.code === "xx";
    case "Y-Linked": return sex === "M" && g.code === "Y*";
    case "Mitochondrial": return g.code === "m";
  }
}

// -----------------------------
// Layout (pedigree-style)
// -----------------------------

const NODE_W = 32; const NODE_H = 32; const COUPLE_GAP = 22; const CHILD_GAP = 44; const SUBTREE_GAP = 30; const LEVEL_GAP = 90;
const coupleKey = (a: string, b: string) => [a,b].sort().join("|");

function buildFamilies(ped: Pedigree){
  const nodesById = Object.fromEntries(ped.nodes.map(n=>[n.id,n] as const));
  const couples = new Map<string,{a:string;b:string;children:string[]}>();
  const parentCoupleOf: Record<string,string|undefined> = {};
  for(const n of ped.nodes){ if(n.spouseId && n.id < n.spouseId){ couples.set(coupleKey(n.id,n.spouseId), {a:n.id,b:n.spouseId,children:[]}); } }
  for(const n of ped.nodes){ if(n.fatherId && n.motherId){ const k = coupleKey(n.fatherId,n.motherId); if(!couples.has(k)) couples.set(k,{a:n.fatherId,b:n.motherId,children:[]}); couples.get(k)!.children.push(n.id); parentCoupleOf[n.id]=k; } }
  const roots: Array<{type:"couple";key:string}|{type:"single";id:string}> = [];
  for(const k of couples.keys()){ const c = couples.get(k)!; const aPar = nodesById[c.a]; const bPar = nodesById[c.b]; const hasParents = !!(aPar.fatherId||aPar.motherId||bPar.fatherId||bPar.motherId); if(!hasParents) roots.push({type:"couple",key:k}); }
  for(const n of ped.nodes){ if(!(n.fatherId||n.motherId) && !n.spouseId) roots.push({type:"single", id:n.id}); }
  return { couples, parentCoupleOf, roots, nodesById };
}

function computeLayout(ped: Pedigree){
  const { couples, roots, nodesById } = buildFamilies(ped);
  const pos: Record<string,{x:number;y:number}> = {};
  type Subtree = { width:number; place:(x:number,y:number)=>void };
  const nodeLeaf = (id:string):Subtree=>({ width: NODE_W, place:(x,y)=>{ pos[id]={x,y}; } });
  const childSubtree = (id:string):Subtree=>{ const n = nodesById[id]; if(n.spouseId){ const k=coupleKey(n.id,n.spouseId); if(couples.has(k)) return coupleSubtree(k);} return nodeLeaf(id); };
  const coupleSubtree = (k:string):Subtree=>{ const c=couples.get(k)!; const kidTrees=c.children.map(childSubtree); const kidsWidth = kidTrees.length? kidTrees.reduce((a,s)=>a+s.width,0)+(kidTrees.length-1)*CHILD_GAP : NODE_W*2+COUPLE_GAP; const width=Math.max(kidsWidth, NODE_W*2+COUPLE_GAP)+SUBTREE_GAP; return { width, place:(x,y)=>{ const center=x+width/2; const ax=center-COUPLE_GAP/2-NODE_W/2; const bx=center+COUPLE_GAP/2+NODE_W/2; pos[c.a]={x:ax,y}; pos[c.b]={x:bx,y}; if(kidTrees.length){ let cur = x + (width - (kidTrees.reduce((s,t)=>s+t.width,0) + (kidTrees.length-1)*CHILD_GAP))/2; kidTrees.forEach(st=>{ const cx = cur + st.width/2; st.place(cx, y+LEVEL_GAP); cur += st.width + CHILD_GAP; }); } } } };
  const forest:Subtree[] = roots.map(r=> r.type==="couple"? coupleSubtree(r.key): nodeLeaf(r.id));
  const totalWidth = forest.reduce((a,s)=>a+s.width,0) + (forest.length-1)*CHILD_GAP; let cur = -totalWidth/2; forest.forEach(st=>{ st.place(cur+st.width/2,0); cur += st.width + CHILD_GAP; });
  const depth = Math.max(1,...Object.values(pos).map(p=>Math.round(p.y/LEVEL_GAP)+1));
  return { pos, depth } as const;
}

// Generations for simulation ordering
function computeGenerations(ped: Pedigree): string[][]{ const gens:string[][]=[]; const processed=new Set<string>(); const founders=ped.nodes.filter(n=>!n.fatherId && !n.motherId).map(n=>n.id); gens.push(founders); founders.forEach(id=>processed.add(id)); let added=true; while(processed.size < ped.nodes.length && added){ added=false; const layer:string[]=[]; for(const n of ped.nodes){ if(processed.has(n.id)) continue; const okDad=!n.fatherId||processed.has(n.fatherId); const okMom=!n.motherId||processed.has(n.motherId); if(okDad&&okMom) layer.push(n.id); } if(layer.length){ layer.forEach(id=>processed.add(id)); gens.push(layer); added=true; } } if(processed.size < ped.nodes.length){ gens.push(ped.nodes.filter(n=>!processed.has(n.id)).map(n=>n.id)); } return gens; }

// -----------------------------
// Simulation
// -----------------------------

type SimResult = { model: Inheritance; mode: Mode; q: number; geno: Record<string,Geno>; affected: Set<string> };

function simulate(ped: Pedigree): SimResult {
  const model: Inheritance = choice(["Autosomal Dominant","Autosomal Recessive","X-Linked Dominant","X-Linked Recessive","Y-Linked","Mitochondrial"]);
  const mode: Mode = Math.random() < 0.5 ? "common" : "rare";
  const q = model === "Y-Linked" ? 0.02 : mode === "common" ? (0.05 + Math.random()*0.25) : (0.002 + Math.random()*0.006);

  const nodesById = Object.fromEntries(ped.nodes.map(n=>[n.id,n] as const));
  const gens = computeGenerations(ped);
  const geno: Record<string,Geno> = {};

  const marriedIn = (id:string)=>{ const n=nodesById[id]; return !(n.fatherId||n.motherId) && !!n.spouseId; };

  // founders
  for(const id of gens[0]){ const n=nodesById[id]; if(mode==="rare" && marriedIn(id)){ if(model==="Mitochondrial") geno[id]={code:"M"}; else if(model==="Y-Linked") geno[id]= n.sex==="M"? {code:"Y"}:{code:"-"}; else if(model.includes("X-Linked")) geno[id]= n.sex==="M"? {code:"X"}:{code:"XX"}; else geno[id]={code:"AA"}; } else { geno[id]=foundersGenotype(n.sex,model,mode,q);} }
  // descendants
  for(let gi=1; gi<gens.length; gi++){
    for(const id of gens[gi]){
      const n=nodesById[id];
      if((!n.fatherId && !n.motherId) && n.spouseId){ if(mode==="rare"){ if(model==="Mitochondrial") geno[id]={code:"M"}; else if(model==="Y-Linked") geno[id]= n.sex==="M"? {code:"Y"}:{code:"-"}; else if(model.includes("X-Linked")) geno[id]= n.sex==="M"? {code:"X"}:{code:"XX"}; else geno[id]={code:"AA"}; continue; } else { geno[id]=foundersGenotype(n.sex,model,mode,q); continue; } }
      const dad=geno[n.fatherId!]; const mom=geno[n.motherId!]; geno[id]=childFromParents(n.sex,model,dad,mom);
    }
  }

  const affected = new Set<string>();
  for(const n of ped.nodes){ const g=geno[n.id]; if(g && isAffected(model,n.sex,g)) affected.add(n.id); }
  let tries=0; while(affected.size===0 && tries<5){ tries++; return simulate(ped); }
  return { model, mode, q, geno, affected };
}

// -----------------------------
// SVG Renderer
// -----------------------------

function Shape({ n, filled }: { n: Node; filled: boolean }){ const stroke="#0f172a"; const fill = filled? "#111827":"#ffffff"; return n.sex==="M"? (<rect x={-16} y={-16} width={32} height={32} rx={4} ry={4} stroke={stroke} strokeWidth={2} fill={fill}/>) : (<circle r={16} stroke={stroke} strokeWidth={2} fill={fill}/>); }

function PedigreeSVG({ ped, sim }: { ped: Pedigree; sim: SimResult }){
  const { pos, depth } = useMemo(()=>computeLayout(ped), [ped]);

  // Build marriage + sibship bars
  const marriages: Array<[string,string]> = []; const sibships: Array<{father:string; mother:string; kids:string[]}> = [];
  const byCouple = new Map<string,{a:string;b:string;kids:string[]}>();
  for(const n of ped.nodes){ if(n.spouseId && n.id < n.spouseId){ byCouple.set(coupleKey(n.id,n.spouseId), {a:n.id,b:n.spouseId,kids:[]}); } }
  for(const n of ped.nodes){ if(n.fatherId && n.motherId){ const k=coupleKey(n.fatherId,n.motherId); if(!byCouple.has(k)) byCouple.set(k,{a:n.fatherId,b:n.motherId,kids:[]}); byCouple.get(k)!.kids.push(n.id); } }
  for(const [,c] of byCouple){ marriages.push([c.a,c.b]); if(c.kids.length) sibships.push({father:c.a, mother:c.b, kids:c.kids}); }

  const allX = Object.values(pos).map(p=>p.x); const minX=Math.min(...allX)-120; const maxX=Math.max(...allX)+120; const width=maxX-minX; const height=depth*LEVEL_GAP+140;

  return (
    <svg viewBox={`${minX} -80 ${width} ${height}`} className="w-full h-[420px] md:h-[540px]">
      {marriages.map(([a,b])=>{ const A=pos[a]; const B=pos[b]; const y=Math.min(A.y,B.y)-16; return <line key={`m-${a}-${b}`} x1={A.x} y1={y} x2={B.x} y2={y} stroke="#0f172a" strokeWidth={2}/>; })}
      {sibships.map(({father,mother,kids})=>{ const F=pos[father]; const M=pos[mother]; const yBar=Math.max(F.y,M.y)+16; const xLeft=Math.min(F.x,M.x); const xRight=Math.max(F.x,M.x); const xMid=(xLeft+xRight)/2; const kidXs = kids.map(k=>pos[k].x); const barLeft=Math.min(...kidXs)-NODE_W/2; const barRight=Math.max(...kidXs)+NODE_W/2; return (<g key={`sib-${father}-${mother}`}>
        <line x1={xMid} y1={yBar-16} x2={xMid} y2={yBar} stroke="#0f172a" strokeWidth={2}/>
        <line x1={barLeft} y1={yBar} x2={barRight} y2={yBar} stroke="#0f172a" strokeWidth={2}/>
        {kids.map(cid=> (<line key={`cv-${cid}`} x1={pos[cid].x} y1={yBar} x2={pos[cid].x} y2={pos[cid].y-16} stroke="#0f172a" strokeWidth={2}/>))}
      </g>); })}

      {ped.nodes.map(n=>{ const p=pos[n.id]; const affected = sim.affected.has(n.id); return (
        <g key={n.id} transform={`translate(${p.x},${p.y})`}>
          <motion.g initial={{opacity:0, scale:0.9}} animate={{opacity:1, scale:1}} transition={{duration:0.3}}>
            <Shape n={n} filled={affected} />
          </motion.g>
          <text y={28} textAnchor="middle" fontSize={10} fill="#6b7280">{n.id}</text>
        </g>
      ); })}
    </svg>
  );
}

// -----------------------------
// Main Component
// -----------------------------

export default function App(){
  const [ped, setPed] = useState<Pedigree>(choice(PEDS));
  const [seed, setSeed] = useState(0);
  const sim = useMemo(()=>simulate(ped), [ped, seed]);

  const rerollPed = () => setPed(choice(PEDS));
  const rerollModel = () => setSeed(s=>s+1);

  return (
    <div className="min-h-screen w-full bg-slate-50 text-slate-900">
      <div className="max-w-5xl mx-auto p-4 md:p-8">
        <h1 className="text-2xl md:text-3xl font-semibold tracking-tight">Pedigree Inheritance Simulator</h1>
        <p className="text-slate-600 mt-1">Random inheritance model + rarity; affected are filled black.</p>

        <div className="mt-4 flex flex-wrap gap-2">
          <button onClick={rerollPed} className="px-3 py-2 bg-white shadow-sm rounded-xl border hover:shadow transition">New Pedigree</button>
          <button onClick={rerollModel} className="px-3 py-2 bg-white shadow-sm rounded-xl border hover:shadow transition">Resimulate</button>
        </div>

        <div className="mt-4 bg-white border rounded-2xl shadow-sm p-3 md:p-4">
          <PedigreeSVG ped={ped} sim={sim} />
        </div>

        <div className="mt-3 text-sm text-slate-700">
          <div>Model: <span className="font-medium">{sim.model}</span> — Mode: <span className="font-medium">{sim.mode}</span>{sim.model!=="Mitochondrial" && <> — q: {sim.q.toFixed(3)}</>}</div>
          {sim.mode === "rare" && <div className="text-xs text-slate-500">Rare mode: all married-in founders are wildtype.</div>}
        </div>
      </div>
    </div>
  );
}
